/*****************************************************************************/
/* File:      build_list.c                                                   */
/*                                                                           */
/* Purpose:   Erstellung einer Liste von FRAC-Elementen                      */
/*                                                                           */
/*                                                                           */
/* Author:    Annette Silberhorn-Hemminger  (AH)                             */
/*            Institut fuer Wasserbau                                        */
/*            Universitaet Stuttgart                                         */
/*            email: annette.hemminger@iws.de                                */
/*                                                                           */
/*****************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include "functions.h"
/*#include "build_list.h"*/

/*****************************************************************************/
/* Build list with Fractures generated by random                             */
/*****************************************************************************/
struct fracture *add_FRAC_to_list(int frac_nr,
                                  double length[2],
                                  double diagonal[2],
                                  struct point norm,
                                  struct point pt[4],
                                  double frac_aperture)
{
  int i;
  if (frac_nr < 1)
    {
      if ((FRAC = malloc (2*sizeof(struct fracture)))== NULL)
	{
	  perror ("add_FRAC_to_list: malloc()");
	  exit (-1);
	}
    }
  else
    {
      if ((FRAC = realloc(FRAC,(frac_nr+2)*sizeof(struct fracture))) == NULL)
	{
	  perror("add_FRAC_to_list: realloc()");
	  exit (-1);
	}
    }

  FRAC[frac_nr].frac_nr = frac_nr+1;
  for (i=0; i<2; i++) {
     FRAC[frac_nr].length[i]   = length[i];
     FRAC[frac_nr].diagonal[i] = diagonal[i];
  }
  FRAC[frac_nr].norm = norm;
  for (i=0; i<4; i++) {
      FRAC[frac_nr].pt[i] = pt[i];
    }
  FRAC[frac_nr].frac_aperture = frac_aperture;
  FRAC[frac_nr+1].frac_nr = -1;
  
  return FRAC;
}


/*****************************************************************************/
/* Build list with Fractures generated from static points                    */
/*****************************************************************************/
struct fracture *insert_FRAC_into_list(int frac_nr,
                                       double length[2],
                                       double diagonal[2],
                                       struct point norm,
                                       struct point pt[4],
                                       double frac_aperture,
                                       int *current_size)
{
   int i;
   if (frac_nr < 1)
   {
      if ((FRAC = malloc(2*sizeof(struct fracture))) == NULL)
      {
         perror("insert_frac_into_list: malloc()");
         exit(-1);
      }
   }
   else
   {
      if ((FRAC = realloc(FRAC, (frac_nr+2) * sizeof(struct fracture))) == NULL)
      {
         perror("insert_var_into_list: realloc()");
         exit(-1);
      }
   }
 
   FRAC[frac_nr].frac_nr = frac_nr+1;
   for (i=0; i<2; i++) {
      FRAC[frac_nr].length[i]   = length[i];
      FRAC[frac_nr].diagonal[i] = diagonal[i];
   }
   FRAC[frac_nr].norm = norm;
   for (i=0; i<4; i++) {
      FRAC[frac_nr].pt[i]=pt[i];
   }
   FRAC[frac_nr].frac_aperture = frac_aperture;
   FRAC[frac_nr+1].frac_nr = -1;
   *current_size = frac_nr+1;
   return FRAC;
  
}


/*****************************************************************************/
/* Build list with trace elements generated from static, deterministic points*/
/*****************************************************************************/
struct trace *add_TRACE_to_StructTraceList(int trace_nr,
                                           double length,
                                           struct point pt[2],
                                           double frac_aperture,
                                           int *current_size)
{
   int initial_nvertex_on_trace = 20;
      /* in order to avoid a lot of allocation steps, each trace get an array
         of 20 possible 'places' for vertex points (=intersection points) */

   int i;
   if (trace_nr < 1)
   {
      if ((TRACE = malloc(2*sizeof(struct trace))) == NULL)
      {
         perror("add_TRACE_to_StructTraceList: malloc()");
         exit(-1);
      }
   }
   else
   {
      if ((TRACE = realloc(TRACE, (trace_nr+2) * sizeof(struct trace))) == NULL)
      {
         perror("insert_var_into_list: realloc()");
   	     exit(-1);
      }
   }
 
   TRACE[trace_nr].nr = trace_nr+1;
   TRACE[trace_nr].length = length;
   for (i = 0; i < 2; i++)
   {
      TRACE[trace_nr].pt[i]=pt[i];
   }

   TRACE[trace_nr].frac_aperture = frac_aperture;

   TRACE[trace_nr].nvertex_on = 0; 
   if ((TRACE[trace_nr].vertex_on 
          = (int *)malloc(initial_nvertex_on_trace * sizeof(int))) == NULL)
   {
      fprintf(stderr,"Memory allocation failed: 'TRACE[%d].nvertex_on' \n",trace_nr);
      exit (-1);
   }

   for (i=0; i<initial_nvertex_on_trace; i++)
   {
      TRACE[trace_nr].vertex_on[i] = -999; 
      if (i==(initial_nvertex_on_trace-1)) TRACE[trace_nr].vertex_on[i] = -1;
   }

   TRACE[trace_nr].inside_subd3D = -1;

   TRACE[trace_nr+1].nr = -1;
   *current_size = trace_nr+1;

   return TRACE;
}



/*****************************************************************************/
/* Build list with EDGE2D-points                                             */
/*****************************************************************************/
/*****************************************************************************/
/* Build list with trace elements generated from static, deterministic points*/
/*****************************************************************************/
struct trace *add_EDGE2D_to_StructTraceList(int trace_nr,
                                            double length,
                                            struct point pt[2],
                                            double frac_aperture,
                                            int *current_size)
{
   int initial_nvertex_on_trace = 20;
      /* in order to avoid a lot of allocation steps, each trace get an array
         of 20 possible 'places' for vertex points (=intersection points) */

   int i;
   if (trace_nr < 1)
   {
      if ((EDGE2D = malloc(2*sizeof(struct trace))) == NULL)
      {
         perror("add_EDGE2D_to_StructTraceList: malloc()");
         exit(-1);
      }
   }
   else
   {
      if ((EDGE2D = realloc(EDGE2D, (trace_nr+2) * sizeof(struct trace))) == NULL)
      {
         perror("insert_var_into_list: realloc()");
   	     exit(-1);
      }
   }
 
   EDGE2D[trace_nr].nr = trace_nr+1;
   EDGE2D[trace_nr].length = length;
   for (i = 0; i < 2; i++)
   {
      EDGE2D[trace_nr].pt[i]=pt[i];
   }
  
   EDGE2D[trace_nr].frac_aperture = frac_aperture;

   EDGE2D[trace_nr].nvertex_on = 0; 
   if ((EDGE2D[trace_nr].vertex_on  
          = (int *)malloc(initial_nvertex_on_trace * sizeof(int))) == NULL)
   {
      fprintf(stderr,"Memory allocation failed: 'EDGE2D[%d].nvertex_on' \n",trace_nr);
      exit (-1);
   }

   for (i=0; i<initial_nvertex_on_trace; i++)
   {
      EDGE2D[trace_nr].vertex_on[i] = -999; 
      if (i==(initial_nvertex_on_trace-1)) EDGE2D[trace_nr].vertex_on[i] = -1;
   }

   EDGE2D[trace_nr].inside_subd3D = -1;

   EDGE2D[trace_nr+1].nr = -1;
   *current_size = trace_nr+1;

   return EDGE2D;
}


/*****************************************************************************/
/* Build list with VERTEX3D-points                                           */
/*****************************************************************************/
struct vertex *add_VERTEX3D_to_list(int nvertex_nr,
				    struct point s_pt_intersect)
{
   if (nvertex_nr < 1)
   {
      if ((VERTEX3D = (struct vertex *)
	   malloc(2*sizeof(struct vertex))) == NULL)
      {
         fprintf(stderr, "Memory allocation failed:VERTEX3D\n");
         exit (-1);
      }
      /*else VERTEX3D_alloc = 1;*/
   }
   else
   {
      if ((VERTEX3D = (struct vertex *)
	   realloc(VERTEX3D, (nvertex_nr+2)*sizeof(struct vertex))) == NULL)
      {
         fprintf(stderr, "Memory allocation failed:VERTEX3D\n");
         exit (-1);
      }
    }
   VERTEX3D[nvertex_nr].vertex_nr   = nvertex_nr;
   VERTEX3D[nvertex_nr].pt = s_pt_intersect; 
   VERTEX3D[nvertex_nr].inside_subd3D = -1;
   VERTEX3D[nvertex_nr+1].vertex_nr   = -1;

   return VERTEX3D;
}


/*****************************************************************************/
/* Build list with EDGE3D-points                                             */
/*****************************************************************************/
struct edge *add_EDGE3D_to_list(int edge_nr,
				struct point pt_intersect[2],
				int i,
				int j)
{
  if (edge_nr < 1)
    {
      if ((EDGE3D=(struct edge *)malloc (2*sizeof(struct edge))) == NULL)
	{
	  fprintf(stderr,"Memory allocation failed (subdomain.c)\n");
	  exit (-1);
	}
      /*else EDGE3D_alloc = 1;*/
    }
  else
    {
      if ((EDGE3D = (struct edge *)
	   realloc(EDGE3D, (edge_nr+2)*sizeof(struct edge))) == NULL)
	{
	  fprintf(stderr,"Memory allocation failed (subdomain.c)\n");
	  exit (-1);
	}
    }
  EDGE3D[edge_nr].edge_nr      = edge_nr;
  EDGE3D[edge_nr].pt0          = pt_intersect[0]; 
  EDGE3D[edge_nr].pt1          = pt_intersect[1]; 
  EDGE3D[edge_nr+1].edge_nr    = -1;
  EDGE3D[edge_nr].plane_nr[0] = i;
  EDGE3D[edge_nr].plane_nr[1] = j;
  return EDGE3D;
}



/****************************************************************************/
/*  AllocateStructPointList()                                               */
/*                                                                          */
/*   PURPOSE     : allocate memory for a dynamic list of type 'struct point'*/
/*   ARGUMENTS   : int n  = # size of the list ( ... # of elements)         */
/*   RETURN value: list ´point_list´                                        */
/*                                                                          */
/****************************************************************************/
struct point *AllocateStructPointList(int n)
{
   struct point *point_list;

   point_list = (struct point *)malloc(n * sizeof(struct point));

   if (point_list == NULL)
   {
      fprintf(stderr,"Nicht genuegend Speicher fuer point_list (Function AddToPointList)\n");
      exit (-1);
   }
   return (point_list);
}

/****************************************************************************/
/*  AllocateStructEdgeList()                                                */
/*                                                                          */
/*   PURPOSE     : allocate memory for a dynamic list of type 'struct edge' */
/*   ARGUMENTS   : int n  = # size of the list ( ... # of elements)         */
/*   RETURN value: list ´edge_list'                                         */
/*                                                                          */
/****************************************************************************/
struct edge *AllocateStructEdgeList(int n)
{
   struct edge *edge_list;

   edge_list = (struct edge *)malloc(n * sizeof(struct edge));

   if (edge_list == NULL)
   {
      fprintf(stderr,"Nicht genuegend Speicher fuer edge_list (Funktion AddToEdgeList)\n");
      exit (-1);
   }
   return (edge_list);
}


