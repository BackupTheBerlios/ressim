package no.uib.cipr.rs.meshgen.triangle;

import java.util.Hashtable;
import java.util.Map;
import no.uib.cipr.rs.geometry.Point3D;
import no.uib.cipr.rs.meshgen.triangle.TriExc;
import no.uib.cipr.rs.util.Pair;

/**
 * Read points from a .node file generated by Triangle. This class encapsulates
 * a function containing inner functions.
 * 
 * @author roland.kaufmann@cipr.uib.no
 */
class PointParser extends ParserBase {
    // points are called node in the output of the Triangle program
    @Override
    protected String suffix() {
        return "node";
    }

    // only overridden because one cannot inherit constructors
    public PointParser(String stem, int refinement) throws TriExc {
        super(stem, refinement);
    }

    // key statistics read from the header of the file, necessary for
    // parsing each individual line
    private int numOfPoints;

    private int numOfDims;

    private int numOfAttrs;

    private boolean hasBoundaryFlag;

    /**
     * Read the header of the file. This should be the first operation performed
     * on it.
     */
    private void readHeader() throws TriExc {
        // header consists of one line on the format:
        // <num> <dim> <attr> <boundary>
        this.numOfPoints = scanner.nextInt();
        this.numOfDims = scanner.nextInt();
        this.numOfAttrs = scanner.nextInt();
        this.hasBoundaryFlag = (scanner.nextInt() != 0);

        // we cannot read a negative number of points
        if (numOfPoints < 0) {
            throw TriExc.INVALID_COUNT_POINTS.create(numOfPoints);
        }

        // at this point, we can only read two dimensions for each of
        // the triangles, so we assert that it is the case for this file
        if (numOfDims != 2) {
            throw TriExc.NOT_TWO_DIM.create(numOfDims);
        }

        // no more information is anticipated on the header line
        skipRestOfLine();
    }

    /**
     * Read one more point from the file.
     * 
     * @return A pair consisting of the index of the point, and the point
     *         itself, widened to three-dimensions.
     */
    private Pair<Integer, Point3D> readNextNode() {
        // each line look like this:
        // <index> <x> <y> [<attr>...] [<bound>]
        int index = scanner.nextInt();
        double x = scanner.nextDouble();
        double y = scanner.nextDouble();

        // skip all the attributes; we are not interested in those
        for (int i = 0; i < numOfAttrs; i++) {
            scanner.next();
        }

        // skip the boundary flag if we are told that there should be
        // one; we don't use that for anything (we are able to determine
        // boundaries in a more general way later).
        if (hasBoundaryFlag) {
            scanner.next();
        }

        // only one point per line
        skipRestOfLine();

        // all our geometry objects are intrinsicly three-dimensional so
        // we'll have to make sure that we have something for the last,
        // missing dimension also
        double z = 0.;

        // create the point that represents this tuple
        Pair<Integer, Point3D> p = new Pair<Integer, Point3D>(index,
                new Point3D(x, y, z));
        return p;
    }

    /**
     * Read all points to a format that can be used by the mesh configuration.
     * 
     * @return Map from the index the point has in the file to the handle given
     *         by the final structure (which is used when setting up the
     *         triangles later).
     * 
     * @throws TriExc
     *             If an error occurs during file reading, then it is translated
     *             into this domain-specific error
     */
    public Map<Integer, Integer> readAll(PointHandler factory) throws TriExc {
        // read the header to figure out how many points there are in
        // the file
        readHeader();

        // if we managed to read the header, the file cannot look too
        // bad. proceed to construct the array to hold all the nodes and
        // a map with the corresponding index translations.
        factory.prepareForPoints(numOfPoints);

        // since we know how many nodes there are supposed to be in the
        // file, we can optimize the load for the map. since we don't
        // expect any more nodes to be added to the map, we set the load
        // factor (factor before the map is increased) to 100%.
        Map<Integer, Integer> map = new Hashtable<Integer, Integer>(
                numOfPoints, 1.f);

        // loop through each of the points
        for (int i = 0; i < numOfPoints; i++) {
            // read from the file
            Pair<Integer, Point3D> node = readNextNode();

            // get each of the result variables as their own references
            // ndx is the index in our file, whereas pt is the triple of
            // coordinates for the point (we are agnostic about how the
            // structure will store these points later however).
            Integer ndx = node.x();
            Point3D pt = node.y();

            // put the point into the array. each point knows about its
            // own index so that it can perform reverse lookup later
            int handle = factory.onPoint(pt.x(), pt.y(), pt.z());

            // add the mapping of the external index to the internal
            map.put(ndx, handle);
        }

        // finalize the sink
        factory.closePoints();

        // give the map of the file to the outside world
        return map;
    }
}
