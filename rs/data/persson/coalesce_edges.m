% [out_edges] = coalesce_edges (vertices, in_edges, remove_crossings)
%
% Rewrite a set of edges that has originally been split into many fragments into
% a new set of edges from their endpoints only. Use this routine to regenerate
% the fractures and let the algorithm decide how to split them, when you are
% reading fractures from a existing output file.
function [out_edges] = coalesce_edges (vertices, in_edges, remove_crossings)
   % psuedo-constants that identifies each field in the edge "structure" vector
   % the latter four constants are the indices in the augmented matrix.
   x = 1; y = 2; a = 1; b = 2; c = 3; dx = 4; dy = 5; x0 = 6; y0 = 7;
   
   % discard all edges that are part of the host rock (i.e. internal edges that
   % were generated by the triangulation but not by any constraints
   host_rock = 0;
   edges = in_edges (find (ne (in_edges(:, c), host_rock)), :);
   
   % count the number of times each vertex has been used; we use this
   % information to detect whether a node is part of more than one fracture
   vertex_use = tally (edges, length (vertices));
   
   % find the direction of each edge, since we can only coalesce edges that has
   % the same direction into a common constraint
   u = unit_vectors (vertices, edges);
   
   % make all edges point to the right, so that the target of one will be the
   % origin of the next in sequence -- two edges cannot share a point which is
   % both's origin or target
   [u, edges] = sort_to_right (u, edges);
   
   % find the origin coordinate of each edge; since all direction vectors now
   % points to the right, we want to sort the edges so that they start at the
   % left so we can enumerate an edge by simply traversing the sorted list
   v = vertices(edges(:, a), x:y);
   
   % augment the edges with direction vector and origin vertex, since we want to
   % include that information in determining which clusters of vertices that
   % should be grouped together. only keep a small number of decimals for the
   % gradients and the vertices so that points with a slightly different
   % gradient (due to limited precision) is not sorted differently.
   augmented = [edges, num_of_dec(u, 1), num_of_dec(v, 4)];
   
   % sort edges to find pairs that belong to eachother. we take advantage of the
   % fact that the sorting algorithm is stable. note that the sort order is the
   % the same as how the matrix will end out, i.e. they will be sorted primarily
   % by color, then by direction vector and last by origin coordinates.
   augmented = sortrows (augmented, [c, dx, dy, x0, y0]);
   
   % start out with an empty set of edges (though there will be at least one
   % edge in the output set).
   out_edges = [];

   % process all edges as long as there are anyone left; start with the first
   % edge in the list and walk downwards (this loop will always terminate).
   i = 1;   
   while i <= size(augmented, 1),
      % since we have sorted the fragments on coordinate and direction, this
      % will be the leftmost position of the edge and thus the origin of the
      % full constraint.
      origin  = augmented(i, a);

      % for two fragments to be coalesced, they must have the same color and the
      % same direction; this is the "representative" color+direction tuple for
      % the entire quotient (first fragment is chosen as representative).
      current = augmented(i, c:dy);
      
      % pretend that we started at some other fragment that ended up at the 
      % first vertex in the edge; this saves us for special handling below.
      target  = origin;
      
      % gobble fragments into edges as long as they have the same color and
      % direction and are linked together by their endpoints.
      while i <= size(augmented, 1) && ...
            all(augmented(i, c:dy) == current) && augmented(i, a) == target,
         target = augmented(i, b);
         i = i + 1;
         
         % is the vertex is part of more than one fracture? each fracture will 
         % cause the count to rise by one (endpoint) or two (interior point). 
         % however, if two fractures both meet at the same site and continue 
         % afterward, then the count will be more than two. we need to stop 
         % walking along the fracture and spill the current list of segments 
         % when we encounter an intersection. this test is done after we advance
         % the counter by one, so that we don't get stuck on the same point once
         % we encounter a crossing.
         if vertex_use(target) > 2 && remove_crossings,
            break;
         end;
      end;
      
      % spill this set of fragments into one new edge. color is the first 
      % element of the key; all the edges have the same color.
      out_edges = [out_edges; origin, target, current(1)];
   end;